/*++

Module Name:

    device.c - Device handling events for example driver.

Abstract:

   This file contains the device entry points and callbacks.

Environment:

    User-mode Driver Framework 2

--*/

#include "driver.h"
#include "strsafe.h"
#include "device.tmh"
#include <malloc.h>

#include "private.h"
#include "wdfusb.h"

// From usbdlib.h

DEFINE_GUID(GUID_USB_CAPABILITY_CHAINED_MDLS,
    0xf5ceeb23, 0xad90, 0x458c, 0x97, 0x9a, 0xd5, 0x9b, 0x3a, 0xd6, 0x88, 0x4f);

DEFINE_GUID(GUID_USB_CAPABILITY_STATIC_STREAMS,
    0x09051e1f, 0x0dc9, 0x4e6b, 0x8b, 0x12, 0x96, 0x0c, 0xbd, 0x81, 0xaa, 0x8f);

DEFINE_GUID(GUID_USB_CAPABILITY_SELECTIVE_SUSPEND,
    0x755c630d, 0xc8a0, 0x4765, 0x94, 0x6f, 0x90, 0xcc, 0x70, 0x38, 0x56, 0xa4);

DEFINE_GUID(GUID_USB_CAPABILITY_FUNCTION_SUSPEND,
    0xf4563183, 0xd66e, 0x42bd, 0xbd, 0x53, 0x1a, 0xc7, 0xb0, 0x4c, 0xd5, 0x9d);

DEFINE_GUID(GUID_USB_CAPABILITY_HIGH_BANDWIDTH_ISOCH,
    0x9c8a8a27, 0x15f9, 0x42e3, 0xa3, 0x56, 0xcd, 0xa6, 0xae, 0x97, 0xa8, 0xc8);

DEFINE_GUID(GUID_USB_CAPABILITY_DEVICE_CONNECTION_HIGH_SPEED_COMPATIBLE,
    0x81a885a6, 0xf239, 0x42a2, 0x83, 0x97, 0xa5, 0xd9, 0x5b, 0xea, 0x69, 0x53);

DEFINE_GUID(GUID_USB_CAPABILITY_DEVICE_CONNECTION_SUPER_SPEED_COMPATIBLE,
    0x8a2f776c, 0x9bd0, 0x4f29, 0x97, 0x71, 0xc7, 0xa3, 0x88, 0x46, 0xd4, 0xc7);


DEFINE_GUID(GUID_USB_CAPABILITY_TIME_SYNC,
    0xbb6e6472, 0x4be5, 0x44a3, 0x96, 0x41, 0x34, 0x5e, 0x56, 0xac, 0x34, 0x85);

DEFINE_GUID(GUID_USB_CAPABILITY_SSP_ISOCH_PIPE_FLAGS,
    0x59819125, 0x33a3, 0x421a, 0xa5, 0xdd, 0x37, 0x63, 0x9f, 0x30, 0xb9, 0x3e);



NTSTATUS
MWLDXP50USBUMDF2DriverCreateDevice(
    _Inout_ PWDFDEVICE_INIT DeviceInit
    )
/*++

Routine Description:

    Worker routine called to create a device and its software resources.

Arguments:

    DeviceInit - Pointer to an opaque init structure. Memory for this
                    structure will be freed by the framework when the WdfDeviceCreate
                    succeeds. So don't access the structure after that point.

Return Value:

    NTSTATUS

--*/
{
    WDF_PNPPOWER_EVENT_CALLBACKS pnpPowerCallbacks;
    WDF_OBJECT_ATTRIBUTES   deviceAttributes;
    PDEVICE_CONTEXT deviceContext;
    WDFDEVICE device;
    NTSTATUS status;

    DbgPrint("MWLUSB UMDF2 Driver CreateDevice");
    WDF_PNPPOWER_EVENT_CALLBACKS_INIT(&pnpPowerCallbacks);
    pnpPowerCallbacks.EvtDevicePrepareHardware = MWLDXP50USBUMDF2DriverEvtDevicePrepareHardware;
    WdfDeviceInitSetPnpPowerEventCallbacks(DeviceInit, &pnpPowerCallbacks);

    WDF_OBJECT_ATTRIBUTES_INIT_CONTEXT_TYPE(&deviceAttributes, DEVICE_CONTEXT);

    status = WdfDeviceCreate(&DeviceInit, &deviceAttributes, &device);

    if (NT_SUCCESS(status)) {
        //
        // Get a pointer to the device context structure that we just associated
        // with the device object. We define this structure in the device.h
        // header file. GetDeviceContext is an inline function generated by
        // using the WDF_DECLARE_CONTEXT_TYPE_WITH_NAME macro in device.h.
        // This function will do the type checking and return the device context.
        // If you pass a wrong object handle it will return NULL and assert if
        // run under framework verifier mode.
        //
        deviceContext = GetDeviceContext(device);

        //
        // Create a device interface so that applications can find and talk
        // to us.
        //
        status = WdfDeviceCreateDeviceInterface(
            device,
            &GUID_DEVINTERFACE_MWLDXP50USBUMDF2Driver,
            NULL // ReferenceString
            );

        if (NT_SUCCESS(status)) {
            //
            // Initialize the I/O Package and any Queues
            //
            status = MWLDXP50USBUMDF2DriverQueueInitialize(device);
        }
        // Get the DeviceObject context by using accessor function specified in
        // the WDF_DECLARE_CONTEXT_TYPE_WITH_NAME macro for DEVICE_CONTEXT.
        //


    }
    // Creare a well known name (\\.\IIUSB0)
    UNICODE_STRING  unicodeLinkName = { 0 };
    WCHAR           wideLinkName[64] = { 0 };

    static int device_count = 0;
    status = StringCchPrintfW((PWSTR)wideLinkName,
        RTL_NUMBER_OF(wideLinkName),
        L"\\DosDevices\\Global\\IIUSB-%d",
        device_count++);
    if (!NT_SUCCESS(status))
    {
        TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "DeviceCreateWellKnownName: Format symbolic link failed with error: 0x%X\n", status);

        return status;
    }

    RtlInitUnicodeString(&unicodeLinkName, wideLinkName);

    status = WdfDeviceCreateSymbolicLink(device, &unicodeLinkName);

    return status;
}

NTSTATUS
MWLDXP50USBUMDF2DriverEvtDevicePrepareHardware(
    _In_ WDFDEVICE Device,
    _In_ WDFCMRESLIST ResourceList,
    _In_ WDFCMRESLIST ResourceListTranslated
    )
/*++

Routine Description:

    In this callback, the driver does whatever is necessary to make the
    hardware ready to use.  In the case of a USB device, this involves
    reading and selecting descriptors.

Arguments:

    Device - handle to a device

Return Value:

    NT status value

--*/
{
    NTSTATUS status;
    PDEVICE_CONTEXT pDeviceContext;
    WDF_USB_DEVICE_SELECT_CONFIG_PARAMS configParams;

    UNREFERENCED_PARAMETER(ResourceList);
    UNREFERENCED_PARAMETER(ResourceListTranslated);

    TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "%!FUNC! Entry");

    status = STATUS_SUCCESS;
    pDeviceContext = GetDeviceContext(Device);

    //
    // Create a USB device handle so that we can communicate with the
    // underlying USB stack. The WDFUSBDEVICE handle is used to query,
    // configure, and manage all aspects of the USB device.
    // These aspects include device properties, bus properties,
    // and I/O creation and synchronization. We only create the device the first time
    // PrepareHardware is called. If the device is restarted by pnp manager
    // for resource rebalance, we will use the same device handle but then select
    // the interfaces again because the USB stack could reconfigure the device on
    // restart.
    //
    if (pDeviceContext->WdfUsbTargetDevice == NULL) {

#if UMDF_VERSION_MINOR >= 25
        WDF_USB_DEVICE_CREATE_CONFIG createParams;

        WDF_USB_DEVICE_CREATE_CONFIG_INIT(&createParams,
                                          USBD_CLIENT_CONTRACT_VERSION_602);

        status = WdfUsbTargetDeviceCreateWithParameters(Device,
                                                    &createParams,
                                                    WDF_NO_OBJECT_ATTRIBUTES,
                                                    &pDeviceContext->WdfUsbTargetDevice
                                                    );
#else
        status = WdfUsbTargetDeviceCreate(Device,
                                          WDF_NO_OBJECT_ATTRIBUTES,
                                          &pDeviceContext->WdfUsbTargetDevice
                                          );
#endif

        if (!NT_SUCCESS(status)) {
            TraceEvents(TRACE_LEVEL_ERROR, TRACE_DEVICE,
                        "WdfUsbTargetDeviceCreateWithParameters failed 0x%x", status);
            return status;
        }
    }
   

    ConfigureDevice(Device);
    //
    // Select the first configuration of the device, using the first alternate
    // setting of each interface
    //
    WDF_USB_DEVICE_SELECT_CONFIG_PARAMS_INIT_MULTIPLE_INTERFACES(&configParams,
                                                                 0,
                                                                 NULL
                                                                 );
    status = WdfUsbTargetDeviceSelectConfig(pDeviceContext->WdfUsbTargetDevice,
                                            WDF_NO_OBJECT_ATTRIBUTES,
                                            &configParams
                                            );

    if (!NT_SUCCESS(status)) {
        TraceEvents(TRACE_LEVEL_ERROR, TRACE_DEVICE,
                    "WdfUsbTargetDeviceSelectConfig failed 0x%x", status);
        return status;
    }

    WdfUsbTargetDeviceGetDeviceDescriptor(pDeviceContext->WdfUsbTargetDevice,
        &pDeviceContext->UsbDeviceDescriptor);



    TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "%!FUNC! Exit");

    return status;
}



NTSTATUS
ConfigureDevice(
    _In_ WDFDEVICE Device
    )
/*++

Routine Description:

    This helper routine reads the configuration descriptor
    for the device in couple of steps.

Arguments:

    Device - Handle to a framework device

Return Value:

    NTSTATUS - NT status value

--*/
{
    USHORT                        size = 0;
    NTSTATUS                      status;
    PDEVICE_CONTEXT               pDeviceContext;
    PUSB_CONFIGURATION_DESCRIPTOR configurationDescriptor;
    WDF_OBJECT_ATTRIBUTES attributes;
    WDFMEMORY   memory;

    PAGED_CODE();

    //
    // initialize the variables
    //
    configurationDescriptor = NULL;
    pDeviceContext = GetDeviceContext(Device);

    //
    // Read the first configuration descriptor
    // This requires two steps:
    // 1. Ask the WDFUSBDEVICE how big it is
    // 2. Allocate it and get it from the WDFUSBDEVICE
    //
    status = WdfUsbTargetDeviceRetrieveConfigDescriptor(pDeviceContext->WdfUsbTargetDevice,
                                               NULL,
                                               &size);

    if (status != STATUS_BUFFER_TOO_SMALL || size == 0) {
        return status;
    }

    //
    // Create a memory object and specify usbdevice as the parent so that
    // it will be freed automatically.
    //
    WDF_OBJECT_ATTRIBUTES_INIT(&attributes);

    attributes.ParentObject = pDeviceContext->WdfUsbTargetDevice;

    status = WdfMemoryCreate(&attributes,
                             NonPagedPoolNx,
                             'MWLU',
                             size,
                             &memory,
                             &configurationDescriptor);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    status = WdfUsbTargetDeviceRetrieveConfigDescriptor(pDeviceContext->WdfUsbTargetDevice,
                                               configurationDescriptor,
                                               &size);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    pDeviceContext->UsbConfigurationDescriptor = configurationDescriptor;

    status = SelectInterfaces(Device);

    return status;
}

NTSTATUS
SelectInterfaces(
    _In_ WDFDEVICE Device
    )
/*++

Routine Description:

    This helper routine selects the configuration, interface and
    creates a context for every pipe (end point) in that interface.

Arguments:

    Device - Handle to a framework device

Return Value:

    NT status value

--*/
{
    WDF_USB_DEVICE_SELECT_CONFIG_PARAMS configParams;
    NTSTATUS                            status;
    PDEVICE_CONTEXT                     pDeviceContext;
    UCHAR                               i;
    WDF_OBJECT_ATTRIBUTES               pipeAttributes;
    WDF_USB_INTERFACE_SELECT_SETTING_PARAMS selectSettingParams;
    UCHAR                               numberAlternateSettings = 0;
    UCHAR                               numberConfiguredPipes;

    PAGED_CODE();

    pDeviceContext = GetDeviceContext(Device);

    //
    // The device has only one interface and the interface may have multiple
    // alternate settings. It will try to use alternate setting zero if it has
    // non-zero endpoints, otherwise it will try to search an alternate
    // setting with non-zero endpoints.
    //

    WDF_USB_DEVICE_SELECT_CONFIG_PARAMS_INIT_SINGLE_INTERFACE( &configParams);

    WDF_OBJECT_ATTRIBUTES_INIT_CONTEXT_TYPE(&pipeAttributes, PIPE_CONTEXT);

#if (NTDDI_VERSION >= NTDDI_WIN8)
    pipeAttributes.EvtCleanupCallback = MWLUsb_EvtPipeContextCleanup;
#endif

    status = WdfUsbTargetDeviceSelectConfig(pDeviceContext->WdfUsbTargetDevice,
                                        &pipeAttributes,
                                        &configParams);


    if (NT_SUCCESS(status) &&
        WdfUsbTargetDeviceGetNumInterfaces(pDeviceContext->WdfUsbTargetDevice) > 0) {

        status = RetrieveDeviceInformation(Device);
        if (!NT_SUCCESS(status)) {
            MWLUsb_DbgPrint(1, ("RetrieveDeviceInformation failed %x\n", status));
            return status;
        }

        pDeviceContext->UsbInterface =
            configParams.Types.SingleInterface.ConfiguredUsbInterface;

        //
        // This is written to work with Intel 82930 board, OSRUSBFX2, FX2 MUTT and FX3 MUTT
        // devices. The alternate setting zero of MUTT devices don't have any endpoints. So
        // in the code below, we will walk through the list of alternate settings until we
        // find one that has non-zero endpoints.
        //

        numberAlternateSettings = WdfUsbInterfaceGetNumSettings(pDeviceContext->UsbInterface);

        if (numberAlternateSettings <= 0) {
            MWLUsb_DbgPrint(1, ("WdfUsbInterfaceGetNumSettings failed %x\n", status));
        }

        numberConfiguredPipes = 0;

        for (i = 0; i < numberAlternateSettings && numberConfiguredPipes == 0; i++) {

            WDF_USB_INTERFACE_SELECT_SETTING_PARAMS_INIT_SETTING(&selectSettingParams, i);

            WDF_OBJECT_ATTRIBUTES_INIT_CONTEXT_TYPE(&pipeAttributes, PIPE_CONTEXT);

#if (NTDDI_VERSION >= NTDDI_WIN8)
            pipeAttributes.EvtCleanupCallback = MWLUsb_EvtPipeContextCleanup;
#endif

            status = WdfUsbInterfaceSelectSetting(pDeviceContext->UsbInterface,
                                                  &pipeAttributes,
                                                  &selectSettingParams
                                                  );

            if (NT_SUCCESS(status)) {

                numberConfiguredPipes = WdfUsbInterfaceGetNumConfiguredPipes(pDeviceContext->UsbInterface);

                if (numberConfiguredPipes > 0){

                    pDeviceContext->SelectedAlternateSetting = i;

                }

            }

        }

        pDeviceContext->NumberConfiguredPipes = numberConfiguredPipes;

        for (i = 0; i < pDeviceContext->NumberConfiguredPipes; i++) {
            WDFUSBPIPE pipe;

            pipe =  WdfUsbInterfaceGetConfiguredPipe(pDeviceContext->UsbInterface,
                                                    i, //PipeIndex,
                                                    NULL
                                                    );
            if (pDeviceContext->IsDeviceHighSpeed) {
                status = InitializePipeContextForHighSpeedDevice(pipe);
            }
            else {
                status = InitializePipeContextForFullSpeedDevice(pipe);
            }
            if (!NT_SUCCESS(status)) {
                MWLUsb_DbgPrint(1, ("InitializePipeContext failed %x\n", status));
                break;
            }
        }

    }

    return status;
}


NTSTATUS
InitializePipeContextForHighSpeedDevice(
    _In_ WDFUSBPIPE Pipe
    )
/*++

Routine Description

    This function validates all the isoch related fields in the endpoint descriptor
    to make sure it's in comformance with the spec and Microsoft core stack
    implementation and intializes the pipe context.

    The TransferSizePerMicroframe and TransferSizePerFrame values will be
    used in the I/O path to do read and write transfers.

Return Value:

    NT status value

--*/
{
    WDF_USB_PIPE_INFORMATION    pipeInfo;
    PPIPE_CONTEXT               pipeContext;

    PAGED_CODE();

    WDF_USB_PIPE_INFORMATION_INIT(&pipeInfo);
    WdfUsbTargetPipeGetInformation(Pipe, &pipeInfo);

    //
    // We use the pipe context only for isoch endpoints.
    //
    if ((WdfUsbPipeTypeIsochronous != pipeInfo.PipeType)) {
        return STATUS_SUCCESS;
    }

    pipeContext = GetPipeContext(Pipe);

    if (pipeInfo.MaximumPacketSize == 0) {
        MWLUsb_DbgPrint(1, ("MaximumPacketSize in the pipeInfo is invalid (zero)\n"));
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Universal Serial Bus Specification Revision 2.0 5.6.3 Isochronous Transfer
    // Packet Size Constraints: High-speed endpoints are allowed up to 1024-byte data
    // payloads per microframe and allowed up to a maximum of 3 transactions per microframe.
    //
    // For highspeed isoch endpoints, bits 12-11 of wMaxPacketSize in the endpoint descriptor
    // specify the number of additional transactions oppurtunities per microframe.
    // 00 - None (1 transaction per microframe)
    // 01 - 1 additional (2 per microframe)
    // 10 - 2 additional (3 per microframe)
    // 11 - Reserved.
    //
    // Note: MaximumPacketSize of WDF_USB_PIPE_INFORMATION is already adjusted to include
    // additional transactions if it is a high bandwidth pipe.
    //

    if (pipeInfo.MaximumPacketSize > 1024 * 3) {
        MWLUsb_DbgPrint(1, ("MaximumPacketSize in the endpoint descriptor is invalid (>1024*3)\n"));
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Microsoft USB stack only supports bInterval value of 1, 2, 3 and 4 (or polling period of 1, 2, 4 and 8).
    //
    if (pipeInfo.Interval == 0 || pipeInfo.Interval > 4) {
        MWLUsb_DbgPrint(1, ("bInterval value in pipeInfo is invalid (0 or > 4)\n"));
        return STATUS_INVALID_PARAMETER;
    }

    pipeContext->TransferSizePerMicroframe = pipeInfo.MaximumPacketSize;

    //
    // For high-speed isochronous endpoints, the bInterval value is used
    // as the exponent for a 2^(bInterval-1) value expressed in
    // microframes; e.g., a bInterval of 4 means a period of 8 (2^(4-1))
    // microframes. The bInterval value must be from 1 to 16.  NOTE: The
    // USBPORT.SYS driver only supports high-speed isochronous bInterval
    // values of {1, 2, 3, 4}.
    //
    switch (pipeInfo.Interval) {
    case 1:
        //
        // Transfer period is every microframe (8 times a frame).
        //
        pipeContext->TransferSizePerFrame = pipeContext->TransferSizePerMicroframe * 8;
        break;

    case 2:
        //
        // Transfer period is every 2 microframes (4 times a frame).
        //
        pipeContext->TransferSizePerFrame = pipeContext->TransferSizePerMicroframe * 4;
        break;

    case 3:
        //
        // Transfer period is every 4 microframes (2 times a frame).
        //
        pipeContext->TransferSizePerFrame = pipeContext->TransferSizePerMicroframe * 2;
        break;

    case 4:
        //
        // Transfer period is every 8 microframes (1 times a frame).
        //
        pipeContext->TransferSizePerFrame = pipeContext->TransferSizePerMicroframe;
        break;
    }

    MWLUsb_DbgPrint(1, ("MaxPacketSize = %d, bInterval = %d\n",
                       pipeInfo.MaximumPacketSize,
                       pipeInfo.Interval));

    MWLUsb_DbgPrint(1, ("TransferSizePerFrame = %d, TransferSizePerMicroframe = %d\n",
                       pipeContext->TransferSizePerFrame,
                       pipeContext->TransferSizePerMicroframe));

    return STATUS_SUCCESS;
}

NTSTATUS
InitializePipeContextForFullSpeedDevice(
    _In_ WDFUSBPIPE Pipe
    )
/*++

Routine Description

    This function validates all the isoch related fields in the endpoint descriptor
    to make sure it's in comformance with the spec and Microsoft core stack
    implementation and intializes the pipe context.

    The TransferSizePerMicroframe and TransferSizePerFrame values will be
    used in the I/O path to do read and write transfers.

Return Value:

    NT status value

--*/
{
    WDF_USB_PIPE_INFORMATION    pipeInfo;
    PPIPE_CONTEXT               pipeContext;

    PAGED_CODE();

    WDF_USB_PIPE_INFORMATION_INIT(&pipeInfo);
    WdfUsbTargetPipeGetInformation(Pipe, &pipeInfo);

    //
    // We use the pipe context only for isoch endpoints.
    //
    if ((WdfUsbPipeTypeIsochronous != pipeInfo.PipeType)) {
        return STATUS_SUCCESS;
    }

    pipeContext = GetPipeContext(Pipe);

    if (pipeInfo.MaximumPacketSize == 0) {
        MWLUsb_DbgPrint(1, ("MaximumPacketSize in the endpoint descriptor is invalid\n"));
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Universal Serial Bus Specification Revision 2.0
    // 5.6.3 Isochronous Transfer Packet Size Constraints
    //
    // The USB limits the maximum data payload size to 1,023 bytes
    // for each full-speed isochronous endpoint.
    //
    if (pipeInfo.MaximumPacketSize > 1023) {
        MWLUsb_DbgPrint(1, ("MaximumPacketSize in the endpoint descriptor is invalid\n"));
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Microsoft USB stack only supports bInterval value of 1 for
    // full-speed isochronous endpoints.
    //
    if (pipeInfo.Interval != 1) {
        MWLUsb_DbgPrint(1, ("bInterval value in endpoint descriptor is invalid\n"));
        return STATUS_INVALID_PARAMETER;
    }

    pipeContext->TransferSizePerFrame = pipeInfo.MaximumPacketSize;
    pipeContext->TransferSizePerMicroframe = 0;

    MWLUsb_DbgPrint(1, ("TransferSizePerFrame = %d\n", pipeContext->TransferSizePerFrame));

    return STATUS_SUCCESS;
}

NTSTATUS
RetrieveDeviceInformation(
    _In_ WDFDEVICE Device
    )
{
    PDEVICE_CONTEXT             pDeviceContext;
    WDF_USB_DEVICE_INFORMATION  info;
    NTSTATUS                    status;
    USHORT                      numberOfStreams = 0;
    PAGED_CODE();

    pDeviceContext = GetDeviceContext(Device);

    WDF_USB_DEVICE_INFORMATION_INIT(&info);

    //
    // Retrieve USBD version information, port driver capabilites and device
    // capabilites such as speed, power, etc.
    //
    status = WdfUsbTargetDeviceRetrieveInformation(pDeviceContext->WdfUsbTargetDevice,
                                                   &info);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    pDeviceContext->IsDeviceHighSpeed =
        (info.Traits & WDF_USB_DEVICE_TRAIT_AT_HIGH_SPEED) ? TRUE : FALSE;

    MWLUsb_DbgPrint(3, ("DeviceIsHighSpeed: %s\n",
                 pDeviceContext->IsDeviceHighSpeed ? "TRUE" : "FALSE"));

    MWLUsb_DbgPrint(3, ("IsDeviceSelfPowered: %s\n",
        (info.Traits & WDF_USB_DEVICE_TRAIT_SELF_POWERED) ? "TRUE" : "FALSE"));

    MWLUsb_DbgPrint(3, ("IsDeviceRemoteWakeable: %s\n",
        (info.Traits & WDF_USB_DEVICE_TRAIT_REMOTE_WAKE_CAPABLE) ? "TRUE" : "FALSE"));

    status = WdfUsbTargetDeviceQueryUsbCapability(pDeviceContext->WdfUsbTargetDevice,
                                &GUID_USB_CAPABILITY_DEVICE_CONNECTION_SUPER_SPEED_COMPATIBLE,
                                0,
                                NULL,
                                NULL);
    if (NT_SUCCESS(status)) {
        pDeviceContext->IsDeviceSuperSpeed = TRUE;
    }

    MWLUsb_DbgPrint(3, ("DeviceIsSuperSpeed: %s\n",
                 pDeviceContext->IsDeviceSuperSpeed ? "TRUE" : "FALSE"));

    if (pDeviceContext->IsDeviceSuperSpeed == TRUE) {
        status = WdfUsbTargetDeviceQueryUsbCapability(pDeviceContext->WdfUsbTargetDevice,
                                    &GUID_USB_CAPABILITY_STATIC_STREAMS,
                                    sizeof(numberOfStreams),
                                    (PUCHAR)&numberOfStreams,
                                    NULL);
        if (NT_SUCCESS(status)) {
            pDeviceContext->IsStaticStreamsSupported = TRUE;
            pDeviceContext->NumberOfStreamsSupportedByController = numberOfStreams;
        }

        if (pDeviceContext->IsStaticStreamsSupported) {
             MWLUsb_DbgPrint(3, ("Number of Streams supported by the controller:  %d\n", numberOfStreams));
        }
    }

    return STATUS_SUCCESS;
}




NTSTATUS
ReadFdoRegistryKeyValue(
    _In_  WDFDRIVER   Driver,
    _In_ LPWSTR      Name,
    _Out_ PULONG      Value
    )
/*++

Routine Description:

    Can be used to read any REG_DWORD registry value stored
    under Device Parameter.

Arguments:

    Driver - pointer to the device object
    Name - Name of the registry value
    Value -


Return Value:

    NTSTATUS

--*/
{
    WDFKEY      hKey = NULL;
    NTSTATUS    status;
    UNICODE_STRING  valueName;

    UNREFERENCED_PARAMETER(Driver);

    PAGED_CODE();

    *Value = 0;

    status = WdfDriverOpenParametersRegistryKey(WdfGetDriver(),
                                                KEY_READ,
                                                WDF_NO_OBJECT_ATTRIBUTES,
                                                &hKey);

    if (NT_SUCCESS (status)) {

        RtlInitUnicodeString(&valueName,Name);

        status = WdfRegistryQueryULong (hKey,
                                  &valueName,
                                  Value);

        WdfRegistryClose(hKey);
    }

    return status;
}

VOID
MWLUsb_EvtPipeContextCleanup(
    IN WDFOBJECT WdfObject
   )
/*++

Routine Description:

    In this callback, it cleans up pipe context.

Arguments:

    WdfObject - WDFUSBPIPE object

Return Value:

    NULL

--*/
{
    WDFUSBPIPE pipe;
    PPIPE_CONTEXT       pPipeContext = NULL;
    PMWLUSB_STREAM_INFO  pStreamInfo = NULL;

    pipe = (WDFUSBPIPE)WdfObject;
    pPipeContext = GetPipeContext(pipe);

    pPipeContext->StreamConfigured = FALSE;
    pStreamInfo = &pPipeContext->StreamInfo;
    pStreamInfo->NumberOfStreams = 0;
    if(pStreamInfo->StreamList != NULL){
#if WDF_KERNEL_MODE
        ExFreePool(pStreamInfo->StreamList);
#else
        free(pStreamInfo->StreamList);
#endif
        pStreamInfo->StreamList = NULL;
    }
}
